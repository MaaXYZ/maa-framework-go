package main

import (
	"bytes"
	_ "embed"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"text/template"
	"unicode"
)

type EventSinkConfig struct {
	SinkName     string
	ReceiverName string
	ReceiverType string
	InstanceName string
	ContextAware bool

	// Derived / convenience fields for templates
	SinkVar       string // lower-case form of SinkName for variable usage
	InterfaceType string // e.g. "TaskerEventSink"
	AdapterType   string // e.g. "TaskerEventSinkAdapter"
}

var (
	//go:embed templates/event_sink_interface.tpl
	eventSinkTemplate string

	//go:embed templates/event_sink_adapter.tpl
	eventSinkAdapterTemplate string

	//go:embed templates/event_sink_helper.tpl
	eventSinkHelperTemplate string
)

const (
	defaultOutputFile = "./event_sinks_gen.go"
)

var (
	out    = flag.String("output", defaultOutputFile, "output file path (file or directory). default: ./event_sinks_gen.go")
	oshort = flag.String("o", "", "shorthand for -output")
)

func main() {

	flag.Parse()

	outputPath := *out
	if *oshort != "" {
		outputPath = *oshort
	}

	confs := []EventSinkConfig{
		{
			SinkName:     "Tasker",
			ReceiverName: "tasker",
			ReceiverType: "*Tasker",
			InstanceName: "t",
		},
		{
			SinkName:     "Resource",
			ReceiverName: "res",
			ReceiverType: "*Resource",
			InstanceName: "r",
		},
		{
			SinkName:     "Context",
			ReceiverName: "ctx",
			ReceiverType: "*Context",
			InstanceName: "ctx",
			ContextAware: true,
		},
		{
			SinkName:     "Controller",
			ReceiverName: "ctrl",
			ReceiverType: "*Controller",
			InstanceName: "c",
		},
	}

	// parse embedded template
	tmpl := template.Must(template.New("eventsink").Parse(eventSinkTemplate))
	tmplAdapter := template.Must(template.New("eventsink_adapter").Parse(eventSinkAdapterTemplate))
	tmplHelper := template.Must(template.New("eventsink_helper").Parse(eventSinkHelperTemplate))

	// if outputPath is an existing directory, write file inside it with default filename
	if fi, err := os.Stat(outputPath); err == nil && fi.IsDir() {
		outputPath = filepath.Join(outputPath, filepath.Base(defaultOutputFile))
	}

	// buffer generated content, format it, then write to output file
	var buf bytes.Buffer

	if _, err := buf.WriteString("// Code generated by go generate; DO NOT EDIT.\n\npackage maa\n\n"); err != nil {
		panic(err)
	}

	for _, conf := range confs {
		// compute derived fields to improve readability in templates
		conf.InterfaceType = conf.SinkName + "EventSink"
		conf.AdapterType = conf.SinkName + "EventSinkAdapter"
		conf.SinkVar = lowerFirst(conf.SinkName)
		if err := tmpl.Execute(&buf, conf); err != nil {
			panic(err)
		}
		if _, err := buf.WriteString("\n"); err != nil {
			panic(err)
		}

		adapterConf := conf
		if err := tmplAdapter.Execute(&buf, adapterConf); err != nil {
			panic(err)
		}
		if _, err := buf.WriteString("\n"); err != nil {
			panic(err)
		}

		helperConf := conf
		if err := tmplHelper.Execute(&buf, helperConf); err != nil {
			panic(err)
		}
		if _, err := buf.WriteString("\n"); err != nil {
			panic(err)
		}
	}

	formatted, err := format.Source(buf.Bytes())
	var outBytes []byte
	if err != nil {
		fmt.Fprintf(os.Stderr, "gofmt failed: %v\nwriting unformatted output\n", err)
		outBytes = buf.Bytes()
	} else {
		outBytes = formatted
	}

	if err := os.WriteFile(outputPath, outBytes, 0644); err != nil {
		panic(err)
	}

}

func lowerFirst(s string) string {
	if s == "" {
		return s
	}
	runes := []rune(s)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}
